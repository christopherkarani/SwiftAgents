<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>

# Agents Module

## Overview

The agents module contains concrete agent implementations that conform to `AgentRuntime`. Each agent type represents a different execution strategy for LLM-powered task completion.

## Core Protocol

```swift
public protocol AgentRuntime: AnyObject {
    var tools: [any AnyJSONTool] { get }
    var instructions: String { get }
    var configuration: AgentConfiguration { get }
    var memory: (any Memory)? { get }
    var inferenceProvider: (any InferenceProvider)? { get }
    var tracer: (any Tracer)? { get }
    func run(_ input: String, session: (any Session)?, hooks: (any RunHooks)?) async throws -> AgentResult
    func stream(_ input: String, session: (any Session)?, hooks: (any RunHooks)?) -> AsyncThrowingStream<AgentEvent, Error>
    func cancel() async
}
```

## Agent Types

### Agent (Structured Tool Calling)
- **Strategy**: Uses `generateWithToolCalls()` for reliable, structured tool invocation
- **Loop**: Build prompt → call provider with tool schemas → execute tools → add results → repeat until no tool calls
- **Provider resolution**: Explicit → Environment → Foundation Models → Error
- **File**: `Agent.swift`

### ReActAgent (Reasoning + Acting)
- **Strategy**: Thought-Action-Observation text parsing loop
- **Loop**: Think → parse tool call from text → execute tool → observe result → think again
- **Best for**: When structured tool calling isn't available
- **File**: `ReActAgent.swift`

### PlanAndExecuteAgent (Three-Phase)
- **Strategy**: Plan decomposition → execute steps → replan on failure
- **Phases**: Planning → Execution → Replanning
- **Key types**: `ExecutionPlan`, `PlanStep`, `StepStatus`
- **File**: `PlanAndExecuteAgent.swift`

## Shared Properties (from AgentRuntime)
- `tools: [any AnyJSONTool]` — available tools
- `instructions: String` — system prompt
- `configuration: AgentConfiguration` — runtime settings
- `memory: (any Memory)?` — memory system
- `inferenceProvider: (any InferenceProvider)?` — LLM provider
- `inputGuardrails / outputGuardrails` — validation
- `tracer: (any Tracer)?` — observability
- `handoffs: [AnyHandoffConfiguration]` — multi-agent delegation

## Implementation Pattern

```swift
public actor MyAgent: AgentRuntime {
    nonisolated public let tools: [any AnyJSONTool]
    nonisolated public let instructions: String
    nonisolated public let configuration: AgentConfiguration

    public func run(_ input: String, session: (any Session)?, hooks: (any RunHooks)?) async throws -> AgentResult {
        let builder = AgentResult.Builder()
        builder.start()
        // ... execution loop ...
        return builder.setOutput(finalOutput).build()
    }
}
```

## Conventions
- All agent types MUST be `actor` for thread safety
- Use `nonisolated` for immutable properties set at init
- Use `Log.agents` for logging
- Provider resolution follows cascade: explicit → environment → Foundation Models
- Results use `AgentResult.Builder()` for accumulation
- Handoff support via `findHandoffConfiguration()` and `applyHandoffConfiguration()`
